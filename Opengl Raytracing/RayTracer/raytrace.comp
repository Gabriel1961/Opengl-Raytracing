#version 440
#define T_MIN 0.01
#define T_MAX 100
#define SKY_BLUE vec3(.5,.7,1.)
#define WHITE vec3(1.,1.,1.)
#define MAGENTA vec3(1.,0.,1.)
#define RED vec3(1.,0.,0.)
#define GREEN vec3(0.,1.,0.)
#define BLUE vec3(0.,0.,1.)
const float INF = 1. / 0.;
#define MSAA_SAMPLES 8
#define MAX_RSTEP 100


uint hash( uint x ) {
    x += ( x << 10u );
    x ^= ( x >>  6u );
    x += ( x <<  3u );
    x ^= ( x >> 11u );
    x += ( x << 15u );
    return x;
}



// Compound versions of the hashing algorithm I whipped together.
uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }
uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }
uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }



// Construct a float with half-open range [0:1] using low 23 bits.
// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
float floatConstruct( uint m ) {
    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32

    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
    m |= ieeeOne;                          // Add fractional part to 1.0

    float  f = uintBitsToFloat( m );       // Range [1:2]
    return f - 1.0;                        // Range [0:1]
}



// Pseudo-random value in half-open range [0:1].
float random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }
float random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float rand(inout float state){ 
	float val = floatConstruct(hash(floatBitsToUint(state)));
	state = val;
	return val;
}


//float rand(vec3 p){
//    return fract(sin(dot(p, vec3(12.9898, 78.233,254.323))) * 43758.5453);
//}

vec3 randInUnitSph(vec3 p){
	return vec3(random(p),random(p*43.23123),random(p*0.2323))*2 - 1;
}


layout(local_size_x = 1, local_size_y = 1,local_size_z = 1) in;

layout(rgba32f,binding=0) uniform writeonly image2D imgOut;

uniform mat4 camRot = mat4(1);
uniform vec3 camPos = vec3(0,0,0);

struct Ray{
	vec3 o;
	vec3 d;
	vec3 at(float t){
		return o + t*d;
	}
};
struct Hit{
	float t;
	vec3 p;	 // hit point
	vec3 n;  // normal
};
struct Sphere{
	float r;
	vec3 c;
	vec3 col;
};

bool hitObj(Sphere s,Ray r,out Hit hit){
	vec3 co = r.o - s.c;
	float a = dot(r.d,r.d);
	float b = dot(co,r.d);
	float c = dot(co,co) - s.r*s.r;
	float dis = b*b - a*c;
	if(dis > 0){
		float t = (-b-sqrt(dis))/a;
		if(t<T_MAX && t>T_MIN)
		{
			hit.t = t;
			hit.p = r.at(t);
			hit.n = normalize(hit.p - s.c);
			return true;
		}
		t = (-b+sqrt(dis))/a;	
		if(t<T_MAX && t>T_MIN)
		{
			hit.t = t;
			hit.p = r.at(t);
			hit.n = normalize(hit.p - s.c);
			return true;
		}
	}
	return false;	
}

Sphere sphs[] = Sphere[2](
	Sphere(1.,vec3(0.,1.,3.),RED),
	Sphere(50.,vec3(0.,-50.,3.),GREEN)
);

// returns if it bounces
bool colorRay(Ray r,out vec3 rcol,out Ray bounce){
	float closest = INF;
	int closestIdx = -1;
	Hit rec;
	for(int i=0;i<sphs.length();i++){
		Hit hit;
		if(hitObj(sphs[i],r,hit)){
			if(hit.t<closest){
				closest = hit.t;
				closestIdx = i;
				sphs[i].col;
				rec = hit;
			}
		}
	}
	if(closestIdx != -1){
		rcol = sphs[closestIdx].col;
		bounce = Ray(rec.p,randInUnitSph(rec.p)+rec.n);
		return true;
	}
	else{
		float sky = (r.d.y + 1.)*.5;
		rcol = mix(WHITE,SKY_BLUE,sky);
		return false;
	}
}


vec3 colorScene(Ray r){
	float at = 1.;
	float weight = 0.5;
	Ray cr = r;
	for(int i=0;i<MAX_RSTEP;i++){
		vec3 rcol;
		Ray bounce;
		bool res = colorRay(cr,rcol,bounce);
		cr = bounce;
		if(res == false){
			return at * rcol;
		}
		at *= weight;
	}
	return vec3(0,0,0);
}

// something is wrong with this
const vec2 PIXEL_SIZE = 2./vec2(gl_NumWorkGroups.xy);
vec3 colorSceneMSAA(Ray r){
	vec3 col = vec3(0,0,0);
	float state = floatConstruct(hash(gl_GlobalInvocationID.xy));
	for(int i=0;i<MSAA_SAMPLES;i++){
		col += colorScene(Ray(r.o,r.d + vec3(PIXEL_SIZE.x*(2*rand(state)-1),
											 PIXEL_SIZE.y*(2*rand(state)-1),
											 0)));
	}
	col /= float(MSAA_SAMPLES);
	return col;
}


void main() {
	ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = (coord - .5 * gl_NumWorkGroups.xy)/float(.5*gl_NumWorkGroups.xy);

	Ray r = Ray(vec3(0.,0.,0.),vec3(uv,1));
	r.o = camPos;
	r.d = vec3(camRot*vec4(r.d,1));

	vec4 value = vec4(colorSceneMSAA(r),1.);

	imageStore(imgOut,coord,value);
}